%YAML 1.2
---

comment: |-
  LNT syntax for Sublime Text.
  Based on the LNT to LOTOS reference manual:
  ftp://ftp.inrialpes.fr/pub/vasy/publications/cadp/Champelovier-Clerc-Garavel-et-al-10.pdf

name: LNT
# See http://www.sublimetext.com/docs/3/syntax.html
file_extensions:
  - lnt
scope: source.lnt
variables:
  identifier: \b([A-Za-z]\w*)\b

contexts:
  # The prototype context is prepended to all contexts but those setting
  # meta_include_prototype: false.
  prototype:
    - include: comments

  main:
    # The main context is the initial starting point of our syntax.
    # Include other contexts from here (or specify them directly).
    - include: types
    - include: channels
    - include: processes
    - include: functions
    - include: keywords
    - include: numbers
    - include: constants
    - include: operators
    - include: strings

  # gate-declarations:
  #   - include: type-annotation
  #   - match: '({{identifier}})\s*'
  #     captures:
  #       1: variable.parameter.lnt
  #   - match: '\]'
  #     pop: true

  type-annotation:
    - match: '{{identifier}}'
      captures:
        1: entity.name.class.lnt
      pop: true

  types:
    - match: '\btype\b'
      captures:
        0: keyword.declaration.lnt
      push: [inside-type, ident-class]

  inside-type:
    - match: '(?=\()'
      push: signature
    - match: '\b(end)\b\s+\b(type)\b'
      scope: end.type.lnt
      captures:
        1: keyword.declaration.lnt
        2: keyword.declaration.lnt
      set: main
    - include: keywords
    - include: constants
    - include: strings

  channels:
    - match: '\bchannel\b'
      captures:
        0: keyword.declaration.lnt
      push: [ident-class]
      #   2: entity.name.class.lnt
      #   3: keyword.declaration.lnt
      scope: meta.channel.def.lnt
    - match: 'is'
      scope: keyword.declaration.lnt
    - match: '(end)\s+(channel)'
      captures:
        1: keyword.declaration.lnt
        2: keyword.declaration.lnt
      set: main

  processes:
    - match: '\bprocess\b'
      scope: keyword.declaration.lnt
      push: [signature, gates, ident-fun]
    - match: 'is'
      scope: keyword.declaration.lnt
    - match: '\b(end)\s+\b(process)\b'
      captures:
        1: keyword.declaration.lnt
        2: keyword.declaration.lnt
      set: main

  functions:
    - match: '\bfunction\b'
      captures:
        0: keyword.declaration.lnt
      push: [type-annotation, signature, ident-fun]
    - match: 'is'
      scope: keyword.declaration.lnt
    - match: '\b(end)\s+\b(function)\b'
      captures:
        1: keyword.declaration.lnt
        2: keyword.declaration.lnt
      set: main

  ident-class:
    - match: '{{identifier}}\s*'
      scope: entity.name.class.lnt
      pop: true

  ident-fun:
    - match: '{{identifier}}\s*'
      scope: support.function.lnt
      pop: true

  gates:
    - match: '\['
      set:
        - match: '({{identifier}})\s*'
          captures:
            1: variable.parameter.lnt
        - match: (?=:)
          push: type-annotation
        - match: '\]\s*'
          pop: true

  signature:
    - match: '\('
      set:
        - match: '\bin|out\b'
          scope: keyword.control.lnt
        - match: '({{identifier}})\s*'
          captures:
            1: variable.parameter.lnt
        - match: (?=:)
          push: type-annotation
        - match: '\)'
          pop: true
    # Workaround for processes
    - match: 'is'
      scope: keyword.declaration.lnt
      pop: true


  operators:
    - match: =>|:=
      scope: keyword.operator.assignment.lnt
    - match: =|!=|>|<|\b(and|or|not)\b
      scope: keyword.operator.logical.lnt
    - match: \+|-|\*|/|\b(mod|rem|abs|min|max|succ|prec|sign)\b
      scope: keyword.operator.arithmetic.lnt
    - match: \?
      scope: keyword.operator.lnt

  keywords:
    # Note that blackslashes don't need to be escaped within single quoted
    # strings in YAML. When using single quoted strings, only single quotes
    # need to be escaped: this is done by using two single quotes next to each
    # other.
    - match: '\b(|any|array|as|assert|break|by|case|disrupt|else|elsif|end|eval|for|function|hide|if|in|is|list|loop|module|null|of|only|out|par|raise|range|return|select|set|sorted|stop|then|type|use|var|where|while|with)\b'
      scope: keyword.control.lnt



  numbers:
    - match: '\b(?:[0-9][0-9.]*)|(?:\.[0-9]+)\b'
      scope: constant.numeric.lnt

  strings:
    # Strings begin and end with quotes, and use backslashes as an escape
    # character.
    - match: '"'
      scope: punctuation.definition.string.begin.lnt
      push: inside_string

  is:
    - match: 'is'
      scope: keyword.declaration.lnt

  inside_string:
    - meta_include_prototype: false
    - meta_scope: string.quoted.double.lnt
    - match: '\.'
      scope: constant.character.escape.lnt
    - match: '"'
      scope: punctuation.definition.string.end.lnt
      pop: true

  constants:
    - match: '\b(true|false)\b'
      scope: constant.other.lnt


  comments:
    # One-line comments (Ada-style)
    - match: '--'
      scope: punctuation.definition.comment.lnt
      push:
        # This is an anonymous context push for brevity.
        - meta_scope: comment.line.double-hyphen.lnt
        - match: $\n?
          pop: true
      comments:
    # Multiline comments (ML-style)
    - match: '\(\*'
      scope: punctuation.definition.comment.lnt
      push:
        - meta_scope: comment.block.lnt
        - match: '\*\)'
          pop: true

